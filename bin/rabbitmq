#!/usr/bin/env python

import json
import pika
import subprocess
import sys
import uuid

user = sys.argv[1]
passwd = sys.argv[2]
priority = sys.argv[3]
sitename = sys.argv[4]
server = sys.argv[5]
port = sys.argv[6]
ssl = sys.argv[7]
queue_name = 'testRequestQ'
exchange_name = 'priority'
binding_key = str(uuid.uuid4())

try:

  # obtain slide ID
  cmd = 'neuca-get slice_name'
  process = subprocess.Popen(cmd, shell=True,
                           stdout=subprocess.PIPE, 
                           stderr=subprocess.PIPE)

  # wait for the process to terminate
  out, err = process.communicate()
  errcode = process.returncode
  if errcode != 0:
      print out
      print err
      exit(1)
  slice_id = out.strip()

  # obtain wf uuid
  cmd = "grep 'root_wf_uuid' braindump.txt"
  process = subprocess.Popen(cmd, shell=True,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)

  # wait for the process to terminate
  out, err = process.communicate()
  errcode = process.returncode
  if errcode != 0:
    print out
    print err
    exit(1)
  wf_uuid = out.strip().split()[1]

  # binding key

  data = {}
  data['requestType'] = 'modifyNetwork'
  data['req_wfuuid'] = wf_uuid
  data['req_sliceID'] = slice_id
  data['req_endpointSrc'] = 'data'
  data['req_endpointDst'] = sitename
  data['req_flowPriority'] = priority
  data['req_bindingKey'] = binding_key
  data['req_exchange'] = exchange_name
  json_data = json.dumps(data)

  # build connection URL
  if ssl == 'True':
    url = 'amqps://%s:%s@%s:%s/panorama' % (user, passwd, server, port)
  else:
    url = 'amqp://%s:%s@%s:%s/panorama' % (user, passwd, server, port)

  #connection = pika.BlockingConnection(pika.URLParameters('amqps://%s:%s@128.9.136.208:5671/panorama' % (user, passwd)))
  #connection = pika.BlockingConnection(pika.URLParameters('amqp://%s:%s@147.72.248.11:5672/panorama' % (user, passwd)))
  connection = pika.BlockingConnection(pika.URLParameters(url))
  channel = connection.channel()
  channel.queue_declare(queue=queue_name)

  # sending priority
  channel.basic_publish(exchange='', routing_key=queue_name, body='%s' % json_data)


  # wait for authorization to run the job
  result = channel.queue_declare(exclusive=True)
  queue_name = result.method.queue

  print(binding_key)

  channel.queue_bind(exchange=exchange_name, queue=queue_name, routing_key=binding_key)

  def callback(ch, method, properties, body):
    print(" [x] %r:%r" % (method.routing_key, body))
    connection.close()
    exit(0)

  channel.basic_consume(callback, queue=queue_name, no_ack=True)
  channel.start_consuming()

except Exception as e:
  print(e)
